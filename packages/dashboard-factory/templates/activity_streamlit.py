"""
Activity-Native Streamlit Dashboard Template
Generated by Dashboard Factory v1.0
Uses Activity Schema v2.0 data from ACTIVITY_CCODE views
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from snowflake.snowpark import Session
from datetime import datetime, timedelta
import os
import json

# Dashboard configuration (injected during generation)
DASHBOARD_CONFIG = {
    "name": "{{dashboard_name}}",
    "panels": {{panels_json}},
    "timezone": "{{timezone}}",
    "generated_at": "{{generated_at}}",
    "spec_hash": "{{spec_hash}}"
}

# Snowflake connection parameters (from environment)
def get_snowflake_session():
    """Create Snowflake session using environment variables"""
    try:
        connection_params = {
            "account": os.getenv("SNOWFLAKE_ACCOUNT"),
            "user": os.getenv("SNOWFLAKE_USERNAME"),
            "password": os.getenv("SNOWFLAKE_PASSWORD"),
            "database": os.getenv("SNOWFLAKE_DATABASE", "CLAUDE_BI"),
            "schema": os.getenv("SNOWFLAKE_SCHEMA", "ACTIVITY_CCODE"),
            "warehouse": os.getenv("SNOWFLAKE_WAREHOUSE", "CLAUDE_WAREHOUSE"),
            "role": os.getenv("SNOWFLAKE_ROLE", "CLAUDE_BI_ROLE")
        }
        
        session = Session.builder.configs(connection_params).create()
        
        # Set context
        session.sql("USE DATABASE CLAUDE_BI").collect()
        session.sql("USE SCHEMA ACTIVITY_CCODE").collect()
        
        return session
    except Exception as e:
        st.error(f"Failed to connect to Snowflake: {str(e)}")
        st.stop()

@st.cache_data(ttl=300)  # Cache for 5 minutes
def load_panel_data(source_view, limit=None):
    """Load data from Activity view"""
    session = get_snowflake_session()
    
    query = f"SELECT * FROM {source_view}"
    if limit:
        query += f" LIMIT {limit}"
    
    try:
        df = session.sql(query).to_pandas()
        return df
    except Exception as e:
        st.error(f"Failed to load data from {source_view}: {str(e)}")
        return pd.DataFrame()

def render_bar_chart(panel_config, data):
    """Render bar chart panel"""
    if data.empty:
        st.warning(f"No data available for {panel_config['id']}")
        return
    
    x_col = panel_config.get('x', data.columns[0])
    y_col = panel_config.get('y', 'metric_value')
    
    # Ensure columns exist
    if x_col not in data.columns or y_col not in data.columns:
        st.error(f"Required columns not found: {x_col}, {y_col}")
        return
    
    fig = px.bar(
        data,
        x=x_col,
        y=y_col,
        title=panel_config.get('description', 'Bar Chart'),
        color=y_col,
        color_continuous_scale='Blues'
    )
    
    fig.update_layout(
        xaxis_tickangle=-45,
        height=400,
        showlegend=False
    )
    
    st.plotly_chart(fig, use_container_width=True)

def render_histogram(panel_config, data):
    """Render histogram panel"""
    if data.empty:
        st.warning(f"No data available for {panel_config['id']}")
        return
    
    metric_col = panel_config.get('metric', 'value')
    
    if metric_col not in data.columns and 'VALUE' in data.columns:
        metric_col = 'VALUE'
    
    fig = px.histogram(
        data,
        x=metric_col,
        nbins=30,
        title=panel_config.get('description', 'Distribution'),
        labels={metric_col: panel_config.get('metric', 'Value')}
    )
    
    # Add median and p95 lines if available
    if 'MEDIAN' in data.columns and not data['MEDIAN'].isna().all():
        median_val = data['MEDIAN'].iloc[0]
        fig.add_vline(x=median_val, line_dash="dash", line_color="red",
                     annotation_text=f"Median: {median_val:.2f}")
    
    if 'P95' in data.columns and not data['P95'].isna().all():
        p95_val = data['P95'].iloc[0]
        fig.add_vline(x=p95_val, line_dash="dash", line_color="orange",
                     annotation_text=f"P95: {p95_val:.2f}")
    
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

def render_timeseries(panel_config, data):
    """Render time series panel"""
    if data.empty:
        st.warning(f"No data available for {panel_config['id']}")
        return
    
    time_col = 'time_bucket' if 'time_bucket' in data.columns else panel_config.get('x', 'ts')
    y_col = panel_config.get('y', 'metric_value')
    
    # Ensure time column is datetime
    if time_col in data.columns:
        data[time_col] = pd.to_datetime(data[time_col])
    
    fig = px.line(
        data,
        x=time_col,
        y=y_col,
        title=panel_config.get('description', 'Time Series'),
        markers=True
    )
    
    fig.update_layout(
        xaxis_title="Time",
        yaxis_title=panel_config.get('y', 'Value'),
        height=400,
        hovermode='x unified'
    )
    
    st.plotly_chart(fig, use_container_width=True)

def render_metrics(panel_config, data):
    """Render metrics summary panel"""
    if data.empty:
        st.warning(f"No data available for {panel_config['id']}")
        return
    
    st.subheader(panel_config.get('description', 'Activity Metrics'))
    
    # Create columns for metrics
    if len(data) == 1:  # Single row metrics view
        row = data.iloc[0]
        
        # Display key metrics in columns
        metric_cols = st.columns(4)
        
        # Find numeric columns for metrics
        numeric_cols = data.select_dtypes(include=['int64', 'float64']).columns
        
        for idx, col in enumerate(numeric_cols[:4]):
            with metric_cols[idx % 4]:
                # Format column name for display
                display_name = col.replace('_', ' ').title()
                value = row[col]
                
                # Format large numbers
                if isinstance(value, (int, float)):
                    if value > 1000000:
                        formatted_value = f"{value/1000000:.1f}M"
                    elif value > 1000:
                        formatted_value = f"{value/1000:.1f}K"
                    else:
                        formatted_value = f"{value:,.0f}"
                else:
                    formatted_value = str(value)
                
                st.metric(display_name, formatted_value)
        
        # Display any text columns below
        text_cols = data.select_dtypes(include=['object']).columns
        if len(text_cols) > 0:
            st.write("")  # Add spacing
            for col in text_cols:
                if pd.notna(row[col]):
                    st.write(f"**{col.replace('_', ' ').title()}:** {row[col]}")
    else:
        # Multiple rows - show as table
        st.dataframe(data, use_container_width=True)

def render_table(panel_config, data):
    """Render data table panel"""
    if data.empty:
        st.warning(f"No data available for {panel_config['id']}")
        return
    
    st.subheader(panel_config.get('description', 'Data Table'))
    
    # Apply any limit
    limit = panel_config.get('limit', 100)
    if len(data) > limit:
        data = data.head(limit)
        st.info(f"Showing top {limit} rows")
    
    st.dataframe(
        data,
        use_container_width=True,
        hide_index=True
    )

def main():
    """Main dashboard application"""
    
    # Page configuration
    st.set_page_config(
        page_title=DASHBOARD_CONFIG['name'],
        page_icon="ðŸ“Š",
        layout="wide"
    )
    
    # Header
    st.title(f"ðŸ“Š {DASHBOARD_CONFIG['name'].replace('_', ' ').title()}")
    
    # Dashboard metadata
    col1, col2, col3 = st.columns(3)
    with col1:
        st.caption(f"Generated: {DASHBOARD_CONFIG['generated_at']}")
    with col2:
        st.caption(f"Timezone: {DASHBOARD_CONFIG['timezone']}")
    with col3:
        if st.button("ðŸ”„ Refresh"):
            st.cache_data.clear()
            st.rerun()
    
    st.divider()
    
    # Render panels
    panels = DASHBOARD_CONFIG['panels']
    
    # Organize panels in grid layout
    for panel in panels:
        try:
            # Load data for panel
            data = load_panel_data(
                panel['source'],
                panel.get('limit')
            )
            
            # Render based on panel type
            panel_type = panel.get('type', 'table')
            
            with st.container():
                if panel_type == 'bar':
                    render_bar_chart(panel, data)
                elif panel_type == 'histogram':
                    render_histogram(panel, data)
                elif panel_type == 'timeseries':
                    render_timeseries(panel, data)
                elif panel_type == 'metrics':
                    render_metrics(panel, data)
                elif panel_type == 'table':
                    render_table(panel, data)
                else:
                    st.warning(f"Unknown panel type: {panel_type}")
                
                st.divider()
                
        except Exception as e:
            st.error(f"Error rendering panel {panel['id']}: {str(e)}")
    
    # Footer
    st.caption(f"Dashboard ID: {DASHBOARD_CONFIG['spec_hash']} | Powered by Activity Schema v2.0")

if __name__ == "__main__":
    main()