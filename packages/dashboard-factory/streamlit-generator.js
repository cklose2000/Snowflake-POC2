// Streamlit Generator - Creates single-file Snowpark Python apps
// Generates complete Streamlit dashboards that connect to Snowflake objects

const { generateObjectNames, convertCronToLocalDisplay } = require('./schema');

class StreamlitGenerator {
  constructor() {
    this.version = '1.0.0';
    
    // Template configurations for different panel types
    this.panelTemplates = {
      table: this.generateTablePanel.bind(this),
      timeseries: this.generateTimeseriesPanel.bind(this),
      metric: this.generateMetricPanel.bind(this),
      chart: this.generateChartPanel.bind(this)
    };
    
    // Color schemes and styling
    this.themes = {
      executive: {
        primary: '#1f4e79',
        secondary: '#2e86ab', 
        accent: '#a23b72',
        background: '#f8f9fa'
      },
      sales: {
        primary: '#2d5016',
        secondary: '#48a23f',
        accent: '#8bc34a', 
        background: '#f1f8e9'
      },
      ops: {
        primary: '#bf360c',
        secondary: '#ff5722',
        accent: '#ff8a65',
        background: '#fff3e0'
      }
    };
  }

  // Main generation method: spec + objects ‚Üí Streamlit Python code
  async generateApp(spec, objectResults) {
    console.log(`üé® Generating Streamlit app for: ${spec.name}`);
    
    const appCode = this.buildStreamlitApp(spec, objectResults);
    
    console.log(`‚úÖ Generated Streamlit app: ${appCode.length} characters`);
    return appCode;
  }

  // Build complete Streamlit application
  buildStreamlitApp(spec, objectResults) {
    const theme = this.selectTheme(spec.name);
    const objectNames = generateObjectNames(spec);
    
    return `#!/usr/bin/env python3
"""
${spec.name.toUpperCase()} Dashboard
Generated by Dashboard Factory v${this.version}
Auto-generated on ${new Date().toISOString()}
"""

import streamlit as st
import pandas as pd
from snowflake.snowpark.context import get_active_session
from snowflake.snowpark import Session
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta

# Dashboard Configuration
DASHBOARD_NAME = "${spec.name.replace(/_/g, ' ').toUpperCase()}"
TIMEZONE = "${spec.timezone}"
REFRESH_SCHEDULE = "${this.formatScheduleForDisplay(spec)}"
THEME_CONFIG = ${JSON.stringify(theme, null, 2)}

# Initialize Snowflake session
@st.cache_resource
def init_snowflake_session():
    """Initialize Snowflake session using Snowpark."""
    try:
        # Use active session in Snowflake environment
        session = get_active_session()
        return session
    except:
        # Fallback for local development
        st.error("‚ùå Snowflake session not available. Run this app in Snowflake Streamlit.")
        st.stop()

# Data loading functions
${this.generateDataLoaders(spec, objectResults)}

# Visualization functions  
${this.generateVisualizationFunctions(spec)}

# Main dashboard layout
def main():
    """Main dashboard application."""
    
    # Configure page
    st.set_page_config(
        page_title=DASHBOARD_NAME,
        page_icon="üìä",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Custom CSS styling
    st.markdown(f'''
    <style>
    .main-header {{
        background: linear-gradient(90deg, {THEME_CONFIG['primary']}, {THEME_CONFIG['secondary']});
        padding: 1rem;
        border-radius: 10px;
        margin-bottom: 2rem;
    }}
    .metric-card {{
        background-color: {THEME_CONFIG['background']};
        padding: 1rem;
        border-radius: 8px;
        border-left: 4px solid {THEME_CONFIG['accent']};
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }}
    .refresh-info {{
        color: #666;
        font-size: 0.8rem;
        text-align: right;
        margin-top: 1rem;
    }}
    </style>
    ''', unsafe_allow_html=True)
    
    # Header
    st.markdown(f'''
    <div class="main-header">
        <h1 style="color: white; margin: 0;">üìä {DASHBOARD_NAME}</h1>
        <p style="color: #ddd; margin: 0.5rem 0 0 0;">{REFRESH_SCHEDULE}</p>
    </div>
    ''', unsafe_allow_html=True)
    
    # Sidebar controls
    with st.sidebar:
        st.header("üéõÔ∏è Dashboard Controls")
        
        # Refresh data button
        if st.button("üîÑ Refresh Data", type="primary"):
            st.cache_data.clear()
            st.rerun()
        
        st.markdown("---")
        
        # Data quality info
        session = init_snowflake_session()
        st.subheader("üìä Data Quality")
        ${this.generateDataQualityInfo(spec)}
        
        st.markdown("---")
        st.caption(f"Dashboard v${this.version} ‚Ä¢ Generated ${new Date().toLocaleDateString()}")
    
    # Main content panels
    ${this.generateMainPanels(spec)}
    
    # Footer
    st.markdown(f'''
    <div class="refresh-info">
        Last updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} {TIMEZONE}
    </div>
    ''', unsafe_allow_html=True)

if __name__ == "__main__":
    main()
`;
  }

  // Generate data loading functions for each panel
  generateDataLoaders(spec, objectResults) {
    const loaders = [];
    
    for (const panel of spec.panels) {
      const objectNames = generateObjectNames(spec, panel.id);
      const dataSource = panel.top_n ? objectNames.top_view : objectNames.base_table;
      
      loaders.push(`
@st.cache_data(ttl=3600)  # Cache for 1 hour
def load_${panel.id}_data():
    """Load data for ${panel.id} panel."""
    session = init_snowflake_session()
    
    query = '''
        SELECT *,
               ROW_NUMBER() OVER (ORDER BY metric_value DESC) as rank_num
        FROM ${dataSource}
        ORDER BY metric_value DESC
        ${panel.top_n ? `LIMIT ${panel.top_n}` : ''}
    '''
    
    try:
        df = session.sql(query).to_pandas()
        return df
    except Exception as e:
        st.error(f"‚ùå Error loading ${panel.id} data: {str(e)}")
        return pd.DataFrame()
`);
    }
    
    return loaders.join('\n');
  }

  // Generate visualization functions for different panel types
  generateVisualizationFunctions(spec) {
    const functions = [];
    
    for (const panel of spec.panels) {
      const panelFunction = this.panelTemplates[panel.type](panel);
      functions.push(panelFunction);
    }
    
    return functions.join('\n');
  }

  // Generate table panel visualization
  generateTablePanel(panel) {
    const metricLabel = this.getMetricLabel(panel.metric);
    
    return `
def render_${panel.id}_panel():
    """Render ${panel.id} table panel."""
    st.subheader("üìã ${panel.id.replace(/_/g, ' ').toUpperCase()}")
    
    df = load_${panel.id}_data()
    
    if df.empty:
        st.warning("No data available for this panel.")
        return
    
    # Display metrics summary
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total Records", len(df))
    with col2:
        st.metric("${metricLabel} Total", f"{df['metric_value'].sum():,.0f}")
    with col3:
        st.metric("Average ${metricLabel}", f"{df['metric_value'].mean():,.0f}")
    
    # Main table
    st.dataframe(
        df[[col for col in df.columns if col not in ['rank_num', 'last_update_date']]],
        use_container_width=True,
        hide_index=True
    )
    
    # Download button
    csv = df.to_csv(index=False)
    st.download_button(
        label="üì• Download CSV",
        data=csv,
        file_name=f"${panel.id}_{datetime.now().strftime('%Y%m%d')}.csv",
        mime="text/csv"
    )
`;
  }

  // Generate timeseries panel visualization
  generateTimeseriesPanel(panel) {
    const metricLabel = this.getMetricLabel(panel.metric);
    
    return `
def render_${panel.id}_panel():
    """Render ${panel.id} timeseries panel."""
    st.subheader("üìà ${panel.id.replace(/_/g, ' ').toUpperCase()}")
    
    df = load_${panel.id}_data()
    
    if df.empty:
        st.warning("No data available for this panel.")
        return
    
    # Ensure we have date column for timeseries
    date_cols = [col for col in df.columns if 'date' in col.lower() or 'time' in col.lower()]
    if not date_cols:
        st.error("No date column found for timeseries visualization.")
        return
    
    date_col = date_cols[0]
    df[date_col] = pd.to_datetime(df[date_col])
    
    # Create timeseries chart
    fig = px.line(
        df, 
        x=date_col, 
        y='metric_value',
        color='${panel.group_by?.[0] || 'customer_name'}' if '${panel.group_by?.[0] || 'customer_name'}' in df.columns else None,
        title=f"${metricLabel} Trends Over Time",
        labels={'metric_value': '${metricLabel}', date_col: 'Date'}
    )
    
    fig.update_layout(
        height=400,
        showlegend=True,
        hovermode='x unified'
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # Summary stats
    col1, col2 = st.columns(2)
    with col1:
        st.metric("Total ${metricLabel}", f"{df['metric_value'].sum():,.0f}")
    with col2:
        latest_value = df.loc[df[date_col].idxmax(), 'metric_value']
        st.metric("Latest ${metricLabel}", f"{latest_value:,.0f}")
`;
  }

  // Generate metric panel visualization
  generateMetricPanel(panel) {
    const metricLabel = this.getMetricLabel(panel.metric);
    
    return `
def render_${panel.id}_panel():
    """Render ${panel.id} metric panel."""
    st.subheader("üéØ ${panel.id.replace(/_/g, ' ').toUpperCase()}")
    
    df = load_${panel.id}_data()
    
    if df.empty:
        st.warning("No data available for this panel.")
        return
    
    # Large metric display
    total_value = df['metric_value'].sum()
    
    st.markdown(f'''
    <div class="metric-card">
        <h1 style="text-align: center; color: {THEME_CONFIG['primary']}; margin: 0;">
            {total_value:,.0f}
        </h1>
        <p style="text-align: center; margin: 0.5rem 0 0 0; font-size: 1.2rem;">
            ${metricLabel}
        </p>
    </div>
    ''', unsafe_allow_html=True)
    
    # Breakdown by category if group_by exists
    if len(df) > 1:
        st.subheader("üìä Breakdown")
        
        fig = px.pie(
            df, 
            values='metric_value',
            names='${panel.group_by?.[0] || 'customer_name'}',
            title=f"${metricLabel} by ${panel.group_by?.[0]?.replace(/_/g, ' ') || 'Category'}"
        )
        
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)
`;
  }

  // Generate chart panel visualization
  generateChartPanel(panel) {
    return `
def render_${panel.id}_panel():
    """Render ${panel.id} chart panel."""
    st.subheader("üìä ${panel.id.replace(/_/g, ' ').toUpperCase()}")
    
    df = load_${panel.id}_data()
    
    if df.empty:
        st.warning("No data available for this panel.")
        return
    
    # Bar chart visualization
    fig = px.bar(
        df.head(${panel.top_n || 10}), 
        x='${panel.group_by?.[0] || 'customer_name'}',
        y='metric_value',
        title="${this.getMetricLabel(panel.metric)} by ${panel.group_by?.[0]?.replace(/_/g, ' ') || 'Category'}",
        labels={'metric_value': '${this.getMetricLabel(panel.metric)}'}
    )
    
    fig.update_layout(
        height=400,
        xaxis_tickangle=-45
    )
    
    st.plotly_chart(fig, use_container_width=True)
`;
  }

  // Generate main panels layout
  generateMainPanels(spec) {
    const panels = [];
    
    // Group panels into rows (2 panels per row)
    for (let i = 0; i < spec.panels.length; i += 2) {
      const panel1 = spec.panels[i];
      const panel2 = spec.panels[i + 1];
      
      if (panel2) {
        panels.push(`
    # Row ${Math.floor(i / 2) + 1}
    col1, col2 = st.columns(2)
    
    with col1:
        render_${panel1.id}_panel()
    
    with col2:
        render_${panel2.id}_panel()
`);
      } else {
        panels.push(`
    # Single panel row
    render_${panel1.id}_panel()
`);
      }
    }
    
    return panels.join('\n');
  }

  // Generate data quality information sidebar
  generateDataQualityInfo(spec) {
    const qualityChecks = [];
    
    for (const panel of spec.panels) {
      qualityChecks.push(`
        # ${panel.id} quality
        ${panel.id}_df = load_${panel.id}_data()
        if not ${panel.id}_df.empty:
            st.write(f"‚úÖ ${panel.id}: {len(${panel.id}_df)} records")
            if 'last_update_date' in ${panel.id}_df.columns:
                latest_update = ${panel.id}_df['last_update_date'].max()
                st.caption(f"Updated: {latest_update}")
        else:
            st.write(f"‚ùå ${panel.id}: No data")
`);
    }
    
    return qualityChecks.join('\n');
  }

  // Select theme based on dashboard name
  selectTheme(dashboardName) {
    const name = dashboardName.toLowerCase();
    
    if (name.includes('sales') || name.includes('revenue')) {
      return this.themes.sales;
    } else if (name.includes('ops') || name.includes('system') || name.includes('monitor')) {
      return this.themes.ops;
    } else {
      return this.themes.executive;
    }
  }

  // Convert metric to human-readable label
  getMetricLabel(metric) {
    const metricLabels = {
      'COUNT(*)': 'Count',
      'SUM(revenue)': 'Revenue',
      'AVG(revenue)': 'Avg Revenue',
      'MAX(revenue)': 'Max Revenue', 
      'MIN(revenue)': 'Min Revenue',
      'SUM(quantity)': 'Quantity',
      'AVG(quantity)': 'Avg Quantity',
      'COUNT(DISTINCT customer_id)': 'Customers',
      'COUNT(DISTINCT order_id)': 'Orders',
      'SUM(profit)': 'Profit',
      'AVG(profit)': 'Avg Profit'
    };
    
    return metricLabels[metric] || metric;
  }

  // Format schedule for display in the app
  formatScheduleForDisplay(spec) {
    if (spec.schedule.mode === 'exact') {
      return convertCronToLocalDisplay(spec.schedule.cron_utc, spec.timezone);
    } else {
      return `Refreshes within ${spec.schedule.target_lag} of new data`;
    }
  }

  // Generate test/demo version of the app (with mock data)
  generateDemoApp(spec) {
    return `#!/usr/bin/env python3
"""
DEMO VERSION: ${spec.name.toUpperCase()} Dashboard
This is a demonstration version with mock data
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np
from datetime import datetime, timedelta

# Mock data generators
def generate_mock_data():
    """Generate mock data for demo purposes."""
    np.random.seed(42)
    
    customers = ['Acme Corp', 'Beta Industries', 'Gamma LLC', 'Delta Inc', 'Epsilon Co']
    dates = pd.date_range(start='2024-01-01', end='2024-12-31', freq='D')
    
    data = []
    for i, customer in enumerate(customers):
        base_revenue = 10000 + (i * 5000)
        for date in dates[::7]:  # Weekly data
            revenue = base_revenue + np.random.normal(0, 2000)
            data.append({
                'customer_name': customer,
                'order_date': date,
                'metric_value': max(0, revenue),
                'row_count': np.random.randint(1, 20),
                'rank_num': i + 1
            })
    
    return pd.DataFrame(data)

# Demo version of the main app
st.set_page_config(page_title="üìä DEMO: ${spec.name.toUpperCase()}", layout="wide")

st.title("üìä DEMO: ${spec.name.toUpperCase()}")
st.warning("üß™ This is a demonstration version with mock data. Deploy to Snowflake for real data.")

# Generate and display mock data
df = generate_mock_data()

# Simple dashboard layout
col1, col2 = st.columns(2)

with col1:
    st.subheader("üìã Top Customers")
    top_customers = df.groupby('customer_name')['metric_value'].sum().sort_values(ascending=False).head(10)
    st.dataframe(top_customers, use_container_width=True)

with col2:
    st.subheader("üìà Revenue Trends")
    monthly_trends = df.groupby(df['order_date'].dt.to_period('M'))['metric_value'].sum()
    fig = px.line(x=monthly_trends.index.astype(str), y=monthly_trends.values, title="Monthly Revenue")
    st.plotly_chart(fig, use_container_width=True)

st.info("üí° To use this dashboard with real data, deploy it to Snowflake Streamlit and connect to your data warehouse.")
`;
  }

  // Get generator version and capabilities
  getVersion() {
    return {
      version: this.version,
      capabilities: {
        panel_types: Object.keys(this.panelTemplates).length,
        themes: Object.keys(this.themes).length,
        features: [
          'snowpark_integration',
          'plotly_visualizations', 
          'responsive_layout',
          'data_caching',
          'csv_export',
          'real_time_refresh',
          'custom_theming',
          'demo_mode'
        ]
      }
    };
  }
}

module.exports = StreamlitGenerator;