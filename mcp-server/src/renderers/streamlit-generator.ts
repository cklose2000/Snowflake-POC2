export class StreamlitGenerator {
  private contract: any;
  
  constructor(contract: any) {
    this.contract = contract;
  }
  
  generateDashboard(config: any): string {
    const { dashboardId, title, description, queries, database } = config;
    
    return `"""
${title}
${description || 'Generated by MCP Dashboard Factory'}
Dashboard ID: ${dashboardId}
Generated: ${new Date().toISOString()}
"""

import streamlit as st
import snowflake.connector
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import os

# Page configuration
st.set_page_config(
    page_title="${title}",
    page_icon="📊",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for dark theme
st.markdown("""
<style>
    .main {
        padding-top: 2rem;
    }
    .block-container {
        padding-top: 1rem;
        padding-bottom: 1rem;
    }
    h1 {
        color: #7c3aed;
    }
    .stMetric {
        background-color: #1a1b3a;
        padding: 1rem;
        border-radius: 0.5rem;
    }
</style>
""", unsafe_allow_html=True)

# Title and description
st.title("📊 ${title}")
${description ? `st.markdown("${description}")` : ''}
st.markdown("---")

# Sidebar for filters
with st.sidebar:
    st.header("🎛️ Dashboard Controls")
    
    # Refresh button
    if st.button("🔄 Refresh Data", use_container_width=True):
        st.cache_data.clear()
        st.rerun()
    
    # Time range filter
    time_range = st.selectbox(
        "📅 Time Range",
        ["Last 24 Hours", "Last 7 Days", "Last 30 Days", "All Time"],
        index=0
    )
    
    # Info
    st.markdown("---")
    st.caption(f"Dashboard ID: {dashboardId}")
    st.caption(f"Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

# Database connection
@st.cache_resource
def get_connection():
    """Create Snowflake connection"""
    return snowflake.connector.connect(
        account=os.getenv('SNOWFLAKE_ACCOUNT'),
        user=os.getenv('SNOWFLAKE_USERNAME'),
        password=os.getenv('SNOWFLAKE_PASSWORD'),
        database='${database}',
        schema='ANALYTICS',
        warehouse=os.getenv('SNOWFLAKE_WAREHOUSE', 'CLAUDE_WAREHOUSE'),
        role=os.getenv('SNOWFLAKE_ROLE', 'CLAUDE_BI_READONLY')
    )

# Data loading functions
${queries.map((query: any, index: number) => `
@st.cache_data(ttl=3600)
def load_${query.name.toLowerCase().replace(/\s+/g, '_')}_data():
    """Load data for ${query.name}"""
    conn = get_connection()
    query = "SELECT * FROM ${database}.ANALYTICS.${query.viewName}"
    df = pd.read_sql(query, conn)
    conn.close()
    return df

${query.name.toLowerCase().replace(/\s+/g, '_')}_df = load_${query.name.toLowerCase().replace(/\s+/g, '_')}_data()
`).join('')}

# Dashboard layout
tab1, tab2, tab3 = st.tabs(["📈 Overview", "📊 Analysis", "📋 Details"])

with tab1:
    st.header("Overview")
    
    # Metrics row
    col1, col2, col3, col4 = st.columns(4)
    
    ${this.generateMetricsSection(queries)}
    
    # Charts row
    col1, col2 = st.columns(2)
    
    ${this.generateChartsSection(queries)}

with tab2:
    st.header("Detailed Analysis")
    
    ${this.generateAnalysisSection(queries)}

with tab3:
    st.header("Data Tables")
    
    ${this.generateTablesSection(queries)}

# Footer
st.markdown("---")
st.markdown(
    f"""
    <div style='text-align: center; color: #666;'>
        Generated by MCP Dashboard Factory | 
        {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} | 
        <a href='https://github.com/your-repo' target='_blank'>Documentation</a>
    </div>
    """,
    unsafe_allow_html=True
)
`;
  }
  
  private generateMetricsSection(queries: any[]): string {
    const metricQueries = queries.filter(q => q.chart_type === 'metric' || 
                                              (!q.chart_type && q.plan.measures?.length === 1 && !q.plan.dimensions));
    
    if (metricQueries.length === 0) {
      return '# No metrics defined';
    }
    
    return metricQueries.map((query, i) => `
    with col${(i % 4) + 1}:
        if not ${query.name.toLowerCase().replace(/\s+/g, '_')}_df.empty:
            value = ${query.name.toLowerCase().replace(/\s+/g, '_')}_df.iloc[0, 0]
            st.metric(
                label="${query.name}",
                value=f"{value:,.0f}" if isinstance(value, (int, float)) else value,
                delta=None  # Add delta calculation if needed
            )`).join('');
  }
  
  private generateChartsSection(queries: any[]): string {
    const chartQueries = queries.filter(q => q.chart_type && q.chart_type !== 'metric' && q.chart_type !== 'table');
    
    if (chartQueries.length === 0) {
      return '# No charts defined';
    }
    
    return chartQueries.map((query, i) => {
      const dfName = `${query.name.toLowerCase().replace(/\s+/g, '_')}_df`;
      
      let chartCode = '';
      switch (query.chart_type) {
        case 'line':
          chartCode = `
        fig = px.line(${dfName}, 
                      x=${dfName}.columns[0], 
                      y=${dfName}.columns[1],
                      title="${query.name}")
        fig.update_layout(template="plotly_dark")
        st.plotly_chart(fig, use_container_width=True)`;
          break;
        case 'bar':
          chartCode = `
        fig = px.bar(${dfName}, 
                     x=${dfName}.columns[0], 
                     y=${dfName}.columns[1],
                     title="${query.name}")
        fig.update_layout(template="plotly_dark")
        st.plotly_chart(fig, use_container_width=True)`;
          break;
        case 'pie':
          chartCode = `
        fig = px.pie(${dfName}, 
                     names=${dfName}.columns[0], 
                     values=${dfName}.columns[1],
                     title="${query.name}")
        fig.update_layout(template="plotly_dark")
        st.plotly_chart(fig, use_container_width=True)`;
          break;
      }
      
      return `
    with col${(i % 2) + 1}:
        if not ${dfName}.empty:${chartCode}
        else:
            st.info("No data available for ${query.name}")`;
    }).join('');
  }
  
  private generateAnalysisSection(queries: any[]): string {
    return queries.map(query => {
      const dfName = `${query.name.toLowerCase().replace(/\s+/g, '_')}_df`;
      
      return `
    # ${query.name}
    if not ${dfName}.empty:
        # Summary statistics
        st.subheader("Summary Statistics")
        st.dataframe(${dfName}.describe())
        
        # Data preview
        st.subheader("Data Preview")
        st.dataframe(${dfName}.head(10))
    else:
        st.info("No data available for ${query.name}")
    
    st.markdown("---")`;
    }).join('\n');
  }
  
  private generateTablesSection(queries: any[]): string {
    return queries.map(query => {
      const dfName = `${query.name.toLowerCase().replace(/\s+/g, '_')}_df`;
      
      return `
    st.subheader("${query.name}")
    if not ${dfName}.empty:
        st.dataframe(
            ${dfName},
            use_container_width=True,
            hide_index=True
        )
        
        # Download button
        csv = ${dfName}.to_csv(index=False)
        st.download_button(
            label="📥 Download CSV",
            data=csv,
            file_name="${query.name.toLowerCase().replace(/\s+/g, '_')}.csv",
            mime="text/csv"
        )
    else:
        st.info("No data available")
    
    st.markdown("---")`;
    }).join('\n');
  }
}